[TIPS]
- 본 설명글은 경험으로 쓰여진 팁입니다.
    실제 제가 프로젝트를 주도하거나 참여하며 개발하고 개선했던 사례 중,
    기록하고 곱씹으면 좋겠다고 생각한 경험을 정리한 글로,
    이미 알고 있는 내용이라도, 한번쯤 읽어보고 환기하면 좋을 것이라 생각합니다.

- 트랜젝션 사용 API 를 비동기 실행시 오작동을 할 수 있습니다.
    예를들어 A 테이블의 a 컬럼이 null 이 아닌지 확인하고 null 이 아니라면 값을 입력하는 api 를 동시에 요청받았을 때,
    이는 서로 다른 두 스레드에서 동시 실행이 되며, 실행하는 도중에는 트랜젝션 내에서 동작하므로, 두 요청 모두 null 체크를 통과한 상태로 진행을 하게 될 것입니다.
    이러한 경우를 방지하려면 데이터베이스에 락을 걸어두면 됩니다.

- 데이터베이스 기초 지식으로, MySQL 에서 Nullable 컬럼에는 Unique 제약을 하지 마세요.
    예를들어 Nullable 컬럼인 a 와 b 를 합성 Unique 로 설정했을 때,
    a 를 null 로 하고, b 를 2 로 입력하고,
    다음에 또 a 를 null 로 하고 b 를 2 로 입력했을 때, 이것이 차단될 것이라고 생각하겠지만, null 이 들어간 순간 unique 제약은 동작을 하지 않고,
    이상 없이 값이 들어갈 것입니다.
    꼭 입력해야 한다면, 실제 변수는 not null 로 두고, null 에 해당하는 기본값을 정해놓아 사용하면 됩니다.

- JPA 네이티브 쿼리에서
    TRUE, 혹은 FALSE 로 반환되는 변수는 매핑 객체에서 Boolean 그대로 받을 수 없고,
    Long 타입으로 받습니다. (1L == True, 0L == False)

    IF(
        join_info.uid IS NOT NULL AND
            (
                select
                count(*)
                FROM
                coverage_request
                where
                join_info_uid = join_info.uid and
                row_delete_date_str='-' and
                reject_or_payment_date is NULL
            ) >0,
            TRUE,
            FALSE
    ) AS insuranceRequest

    예를들어 위와 같이 TRUE, 혹은 FALSE 를 반환하는 변수  insuranceRequest 를 받으려면,

    interface NativeQueryOutputVo {
        var insuranceRequest: Long
    }

    이처럼 Long 으로 받도록 만들어야 합니다.(참 : 1, 거짓 : 0)

    다만, 원래 변수 타입이 Boolean(BIT(1)) 인 변수를 그대로 받거나, 혹은
    join_info.coverage_expired_date < NOW() AS insuranceExpired
    위와 같이 비교문 반환값으로 나오는 변수의 경우는 Boolean 으로 받을 수 있습니다.

- API 컨트롤러의 변수명으로는 isXXX 란 이름을 사용하지 마세요.
    예를들어, isEmpty 라는 변수명을 반환하도록 설계하였다면,
    매핑시 isEmpty 가 반환되는 것이 아니라 empty 라는 이름으로 반환이 될 것입니다.

- JPA 네이티브 쿼리에서 sum 으로 값을 더하여 가져올 때, sum 결과물이 null 이 될 수 있습니다.
    검색 데이터가 아예 없는 경우,
    그리고 nullable 타입의 컬럼에 sum 을 할 때, 검색된 결과가 모두 null 일 경우가 그러합니다.
    (하나라도 검색이 되었다면, null 부분은 0 으로 다루어 더해집니다.)
    요약하자면, sum 결과값은 Long? 으로 받으세요.

- JPA 네이티브 쿼리에서 복잡한 기능, 특정 데이터베이스 엔진의 제공 함수는 최대한 배제합시다.
    데이터베이스 엔진 변경, 버전업 등에 영향을 받을 수 있으므로 관리가 어려워집니다.

- 보안을 위하여,
    Rest 서버에서는 오로지 정해진 클라이언트의 IP 에서만 요청을 받도록 AWS 와 같은 플랫폼 단에서 다른 요청들을 블록하도록 처리하는 것이 좋습니다.
    이렇게 되면 당연히 서버는 UI 를 제공하는 기능을 잃어버리겠지만, 오히려 역할의 명확한 분담이란 측면에서 관리가 용이해집니다.

- JPA 에서 DATETIME 변수를 다룰 때는 자동으로 TimeZone 을 맞춰줍니다.
    예를들어 JPA 가 UTC, 데이터베이스가 KST 시간을 사용중이라고 했을 때,
    JPA 에서 UTC 시간인 2024-05-02 03:38:46.026 를 데이터베이스에 입력하면,
    데이터베이스에는 실제로는 KST 시간인 2024-05-02 12:38:46.026 가 저장이 되며,
    데이터베이스에서 KST 시간인 2024-05-02 12:38:46.026 를 조회하면,
    UTC 시간을 사용중인 스프링부트 시스템에 맞춰서 JPA 는,
    2024-05-02 03:38:46.026 라고 데이터를 변환해줄 것입니다.

- 혼란을 피하고 싶다면, 날짜 데이터에 타임존을 표시하는 것이 좋습니다.
    yyyy_MM_dd_'T'_HH_mm_ss_SSS_z
    위와 같은 표현 방식이라면,
    2024_05_02_T_14_22_23_272_KST
    이렇게 일시 표현이 되며,
    이를 통하여 해당 시간의 기준이 되는 타임존을 한눈에 알 수 있기에 오해를 방지할 수 있습니다.
    또한, 위에서 명확한 일시 표현을 위하여,
    yyyy-MM-dd_'T'_HH:mm:ss.SSS_z
    이련 형식을 사용할 수도 있겠지만, 일시 데이터가 파일명으로 사용될 수 있을 경우를 생각하여 분리자를 '_' 로 표현한 것이므로,
    상황에 따라 다를 테지만 거의 공통적으로 위와 같인 표현방식을 사용하면 일관성으로 인하여 편할 것이라고 생각합니다.
    년, 월, 일, 시, 분, 초, 밀리초 의 경우 어디까지 표현할지에 대한 것은 상황에 맞게 선택하세요.
    저는 보통 시간 저장시 밀리초 3자리 까지 저장하는데, 때에 따라 달라질 수도 있습니다.

- application.yml 에서,
    datasource.{데이터베이스}.jdbcUrl 에 serverTimezone 설정은 해당 데이터베이스가 사용중인 타임존을 설정하면 됩니다.
    ApplicationConstants.SYSTEM_TIME_ZONE 는 본 서버 프로젝트의 타임존 설정으로,
    이 둘을 설정했다면, 개발자는 JPA 를 사용하여 데이터베이스의 날짜 데이터를 다룰 때, 본 서버의 타임존만을 고려하면 됩니다.
    예를들어 본 서버의 타임존이 Asia/Seoul 로 설정되어있고,
    데이터베이스의 타임존은 serverTimezone=UTC 로 설정되어 있다고 합시다.
    서버 코드로 LocalDatetime.now() 로 현재 시간을 가져온다면 이는 Asia/Seoul 의 현 시간인데,
    이를 UTC 기준 데이터베이스에 입력하려면 당연히 타임존 변환 후 저장을 해야겠죠?
    만약 지금이 Asia/Seoul 기준 19시라면, UTC 기준으로는 -9시간을 하여 10시가 되는 것입니다.
    원래라면 이렇게 변환을 거쳐서 입력을 하고,
    또한 UTC 로 저장된 날짜 데이터를 조회할 때에는 +9 를 하여 다뤄야 하지만,
    JPA 에서 serverTimezone 을 설정하여 데이터베이스의 타임존을 설정해주었다면,
    입 출력시에 자동으로 변환이 됩니다.

    테스트를 하고 싶다면, 앞서 설명대로,
    ApplicationConstants.SYSTEM_TIME_ZONE 을 Asia/Seoul 로 설정하고,
    datasource.{데이터베이스}.jdbcUrl 에 serverTimezone 설정을 UTC 로 설정한 상태에서,
    API C7-N1 입력값 중 dateString 에,
    2024_05_02_T_19_00_00_000
    을 입력해보세요.
    그리고 데이터베이스를 확인하면, 저장된 값은 KST 기준 날짜가 UTC 기준으로 변환된
    2024_05_02_T_10_00_00_000 이 저장되어 있는 것을 볼 수 있습니다.
    반대로, API C7-N4 로 방금 저장된 날짜를 조회한다면,
    데이터베이스에는 2024_05_02_T_10_00_00_000 로 저장되어 있지만,
    2024_05_02_T_19_00_00_000_KST 로 받아오는 것을 확인할 수 있을 것입니다.

    주의할 점은, serverTimezone 설정은 실제 데이터베이스 설정과 동기화 되지 않습니다.
    무슨 의미냐면, 실제로 데이터베이스가 KST 시간을 써도, serverTimezone 설정을 UTC 로 적는다면,
    JPA 날짜 변환 기준은 본 서버 타임존과 serverTimezone 설정을 기준으로 한다는 것으로 이 설정을 수동으로
    데이터베이스에 맞추는 것이 중요하다는 것입니다.

    데이터베이스에서 현재 설정된 타임존을 알기 위해서는,
    select @@global.time_zone, @@session.time_zone;

    데이터베이스 타임존을 설정하기 위해서는
    SET GLOBAL time_zone='+00:00';
    SET time_zone='+00:00';

    위와 같이 입력하면 됩니다.

    추가로, serverTimezone 설정을 적지 않는다면, JPA 는 데이터베이스의 타임존이 서버 타임존과 일치한다고 간주할 것입니다.

- Swagger 에서 Enum 타입의 상수값에 대한 설명을 어노테이션으로 달 수는 없으니,
    이 타입을 사용하는 변수 부분의 설명에 Enum 각 상수에 대한 설명을 달아줘야 합니다.

- SQL 쿼리 작성 권장사항
    제 코드 작성 우선순위는, 가독성과 유지보수성이 1순위고, 그 외에는 상황에 따라 달라집니다.
    쿼리 작성 우선순위 역시 동일합니다.

    제 기준의 쿼리 작성 규칙을 정리하자면,

    1. 쿼리문은 서브쿼리를 최대한 줄이고, Join 역시 할 수 있다면 줄이자.
    2. 특히 From, Join 내에서 서브쿼리를 사용하는 것은 최대한 피하자.

    위와 같습니다.

    1 번 규칙은 앞서 말한 가독성과 성능을 위한 것이고,

    2 번 규칙은, 제 경험상 JOIN 문 부분에 서브쿼리를 사용했을 때,
    데이터베이스 종류에 따라 에러 발생의 원인이 될 수 있는 부분이기에 무엇보다 주의해야 합니다.
    굳이 사용해야 하는 일이 있다면 반드시 테스트를 하는 것이 필수입니다.

    물론 위와 같은 규칙들은 절대적인 것이 아니므로 상황에 따라 최선의 방법을 사용합시다.

- 데이터베이스 성능 향상 순서
    1. 쿼리문 최적화
    2. Redis 를 이용한 정보 조회 캐싱
    3. 마스터, 슬레이브 구조로 데이터베이스 분산

- 데이터베이스 설계 팁
    데이터베이스 설계 단계에서는 정석적인 방식을 사용하세요.
    데이터베이스는 데이터를 효율적으로 저장하기 위해 존재하는 것으로,
    이 리소스를 기반으로 하여 서비스가 구축되는 것입니다.

    본인이 데이터 설계를 하는 입장이라면 본인이 순수한 데이터베이스 아키텍쳐의 입장으로써,
    데이터의 효율적인 저장 목적 외의 기능은 전혀 고려하지 않는다고 가정하고,
    개발을 하는 입장이라면 데이터 설계가 끝날 때 까지 절대 관여하지 않는다고 가정합시다.

    데이터베이스 설계를 가장 효율적으로 한 상태에서 개발자의 개발이 시작되는 것입니다.

    서비스 개발 단계에서 데이터베이스 설계시 주의해야 하는 것은,
    위와 같은 정석을 무시하고 서비스 구현을 빠르고 편하게 하기 위하여 데이터베이스 구조를 서비스에 맞춰버리는 것을 경계하는 일입니다.

    예를 들어보겠습니다.

    멤버 정보 테이블이 존재하고, 이 안에 이름, 전화번호, 이메일 과 같은 데이터가 존재한다고 합시다.
    이때, 서비스 기획에서 서비스 튜토리얼 화면을 만들고, 이를 멤버에게 가입한 이후 딱 한번만 보여주도록 했다고 합시다.
    그렇다면 멤버별 해당 튜토리얼 화면을 봤는지를 데이터베이스에 기록하고 확인해야 할 것입니다.

    이러한 데이터를 멤버 정보 테이블에 넣어야 할까요?
    그렇게 한다면 개발을 하는 입장에서는 편할 것입니다.

    하지만, 이번 버전에 있던 튜토리얼 기능을 다음 버전에서는 없애버렸다고 가정합시다.
    위와 같이 처리한 상태에서는,
    Row 하나가 생성될 때 마다 현재 시점에는 사용하지도 않을 컬럼에도 임의로 값을 지정해줘야 하며,
    이렇듯 미사용 컬럼이 늘어난다면 결코 좋지 않을 것입니다.

    또한, 해당 데이터베이스 테이블의 정보를 다른 서비스에서 사용한다고 가정한다면,
    이미 다른 서비스에 특화된 구조는 데이터 해석에 오히려 방해가 될 수 있습니다.

    이러한 문제를 방지하기 위하여, 데이터베이스 테이블을 서비스 로직에 특화되어 만드는 것을 피해야 합니다.

    그렇다면 위와 같은 상황을 어떻게 회피할까요?

    바로 서비스용 테이블을 따로 만드는 것입니다.

    멤버 테이블에서 이름, 연락처, 주소와 같이 테이블 주제에 부합하며,
    서비스 기능에 상관 없이 변화하지 않을 핵심 정보만을 가지고 있는 핵심 테이블을 만들었다면,

    튜토리얼 서비스 기능을 구현하기 위해 필요한 정보를 저장할 때에는,
    멤버 테이블을 외래키로 두고, 이를 유니크 값으로 처리하도록 하며, 튜토리얼 진행 여부를 기록하여 사용하면 됩니다.

    이렇게 서비스를 위한 서비스용 테이블을 따로 둔다면,
    조회에 JOIN 을 사용해야 하는 등, 사용상 불편이 따르기는 할테지만,
    데이터베이스 테이블 구조를 깔끔하게 유지하며, 앞서 설명한 문제를 방지할 수 있습니다.

- API 설계 방침
    데이터베이스에는 Long 타입으로 가격 정보가 100000 이라고 저장된 경우,
    프론트엔드 개발자의 개발 스타일에 따라, 어떤 분은 100000 의 숫자 데이터를 보내달라고 하기도 하고,

    어떤 분은 아예 "100,000원" 이처럼 화면에 표현되는 데이터 그대로 전달해달라고 하는 경우도 있습니다.

    전자를 Code Only 반환 법칙이라고 하고,
    후자를 Label 반환 법칙이라고 가칭하겠습니다.

    Code Only 반환 법칙의 장점은, 네트워크로 이동하는 데이터량을 그만큼 줄일수 있고,
    서버측에서 데이터 가공에 들어가는 연산량을 아낄 수 있으며,
    API 재활용성이 좋아지는 등의 장점이 있습니다.
    즉, 백엔드 개발자에게 유리한 방식입니다.

    Label 반환 법칙은 화면에 나타나는 변할 수 있는 문자열 데이터를 반환하는 것입니다.
    데이터베이스에서 출생일이 0000년 00월 00일 로 저장되어 있는 상태에서,
    화면에서는 00살 이라고 표시하기를 원한다면, 출생일 데이터를 계산하여 화면에 표시되는 데이터를 반환해주는 것이죠.
    이 뿐만이 아닙니다.
    Label 반환 법칙이라고 Label 데이터만을 반환하는 것이 아니라,
    코드상에서 사용할 불변의 코드 데이터도 역시 같이 보내줘야 합니다.

    예를들어 화면에야 00살이라고 표시하더라도,
    화면 기능상 10 살이 넘어가면 특별한 기호를 표시하는 등의 처리를 해야한다고 할 때,

    if(labelAge == "10살")

    이런식으로 Label 데이터를 비교에 사용하면 안됩니다.
    Label 데이터는 String 타입으로, 이를 사용하는 이유는, 서버측에서 클라이언트에 표시할 데이터 가공 권한을 가지겠다는 것입니다.
    이번에는 "10살" 이라고 표시한 것이, 후에는 "10살 11개월"... 이렇게 변경될 가능성이 있으므로,
    라벨 데이터는 조건문 등에 사용하면 안됩니다.

    이때는 표현법과 상관없이 불변하는 코드 데이터로, 0000-00-00 이런식으로 데이터를 반환해야 하죠.

    이렇게 보면 프론트엔드 개발자가 데이터를 받아서 바로 화면에 표시하는 프론트 친화적 방식이라고 할 수 있네요.
    라벨 반환 법칙을 사용하면 여러모로 백엔드 개발자가 신경쓰고 처리해야 할 일이 많아집니다...

    저의 경우는 Code Only 반환 법칙을 추천합니다.
    제가 백엔드 개발자 입장이라서 그런 것도 있지만,
    다른 이유로는,

    첫째, 라벨 반환 법칙에서 어떤 부분을 라벨 데이터라고 판단하는 기준은,
    기획서 화면상 변화될 가능성이 있는 '문자' 뿐입니다.
    아이콘이나 그외의 형태의 UI 는 라벨 데이터가 아닌 코드 데이터가 강제되죠.
    어떤 것은 라벨 데이터를 반환하고, 어떤 것은 코드 데이터로 받아 처리한다라는 것은 통일성이 없다고 보여집니다.

    둘째, 앞서 설명하였듯, 네트워크로 이동하는 데이터량을 그만큼 줄일 수 있으며, 서버에서 변환에 사용되는 연산량을 아낄 수 있습니다.
    사소하게 보일수도 있지만, 서버는 하나이고, 클라이언트는 이론상 무한일 수 있기에 필요한 조치라고 봅니다.

    셋째, 다국어 처리를 서버에서 떠맡아야 하는 부담을 가지게 됩니다.
    이 경우 그러한 처리를 위하여 서버측 코드에 불합리한 구조를 가지게 되어 유지보수에 악영향을 줍니다.

    위와 같은 이유로 인하여, 저는 제가 프론트 엔드 개발을 맡더라도 Code Only 방식을 사용할 것이라 봅니다.
    (실제 안드로이드 개발시 Cody Only 방식을 따른 경험도 있습니다.)

    다만, Code Only 방식에서 주의해야 할 점이 있습니다.
    이 방식은 자칫 클라이언트 개발자에게 서버측이 담당해야하는 데이터 해석 업무를 떠맡길 가능성이 있다는 것입니다.

    예를들어 특정 상품의 '상태'는, 3가지 종류가 있다고 가정하겠습니다.
    그런데 그러한 상태를 파악하기 위하여 관련된 변수 10 개를 조합해야 한다고 가정했을 때,

    서버측에서 Code Only 방식이라며,
    변수 10 개를 그대로 클라이언트 개발자에게 반환하여 이를 조합하여 상태를 판단하라고 하면 어떤 일이 일어날까요?

    클라이언트 개발자는 변수 조합을 '공부' 해야 할 것입니다.

    이는 단순히 클라이언트 개발자의 수고가 느는 것 뿐 아니라,
    서버측 입장에서도 추후 해당 상태 파악을 위한 기준이 바뀌었을 때,
    이를 일일이 클라이언트 개발자에게 공유해야 합니다.

    이렇게 된다면 서버측에서만 관리해야할 일을 클라이언트 개발자에게 떠넘기는 격이 되며,
    나중에는 서버측의 사소한 로직 변경이 클라이언트측 에러의 원인이 될 수 있기에,
    서버 개발자의 경우에도, 서버 로직 변경뿐 아니라 클라이언트 싱크도 신경써야 하는 수고가 느는 것입니다.

    이처럼 Code Only 방식을 사용한다면 클라이언트 개발자에게 로직을 떠넘기지 않도록 보내주는 데이터를 잘 선정해야만 합니다.

    프로젝트 개발이 시작되어 API 설계를 하는 단계에서 서버 개발자는 클라이언트 개발자에게 위와 같은 사항을 잘 설명하여,
    되도록이면 Code Only 방식을 사용하되, 절대 서버 로직을 클라이언트가 떠안지 않도록 처리하는 것이 중요합니다.