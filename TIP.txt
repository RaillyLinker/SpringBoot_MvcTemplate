[TIP]
- 트랜젝션 사용 API 를 비동기 실행시 오작동을 할 수 있습니다.
    예를들어 A 테이블의 a 컬럼이 null 이 아닌지 확인하고 null 이 아니라면 값을 입력하는 api 를 동시에 요청받았을 때,
    이는 서로 다른 두 스레드에서 동시 실행이 되며, 실행하는 도중에는 트랜젝션 내에서 동작하므로, 두 요청 모두 null 체크를 통과한 상태로 진행을 하게 될 것입니다.
    이러한 경우를 방지하려면 데이터베이스에 락을 걸어두면 됩니다.

- 데이터베이스 기초 지식으로, MySQL 에서 nullable 컬럼에는 unique 제약을 하지 마세요.
    예를들어 nullable 컬럼인 a 와 b 를 합성 unique 로 설정했을 때,
    a 를 null 로 하고, b 를 2 로 입력하고,
    다음에 또 a 를 null 로 하고 b 를 2 로 입력했을 때, 이것이 차단될 것이라고 생각하겠지만, null 이 들어간 순간 unique 제약은 동작을 하지 않고,
    이상 없이 값이 들어갈 것입니다.
    꼭 입력해야 한다면, 실제 변수는 not null 로 두고, null 에 해당하는 기본값을 정해놓아 사용하면 됩니다.

- 서버 개발자는 프로젝트에 들어가면 Raw Data 로 데이터를 뿌려주는 것보다는 기획서에 표시된 클라이언트 화면 단위로 전해주는 것을 우선으로 하세요.

    예를들어 화면에서 품종이라고 표시된 데이터를 요청하면, 데이터베이스에 저장된 0, 1 등의 품종 코드 데이터를 그대로 주는게 아니라,
    펜, 가위와 같이 실제 표시되는 데이터를 넘겨주는 것이 좋습니다.

    Raw Data 반환의 경우,
    서버 입장에서는 가공에 들어가는 연산량을 줄이고 코드를 간결하게 유지하면서,
    실제 화면을 구성하는 모든 정보를 줬기에 끝이라고 생각할 수 있지만,

    클라이언트 입장에서는 해당 변수의 조합을 통해 화면에 표시하는 것이 단순히 추가적인 수고가 드는 일이라기 보다는,
    SEO 에도 연관이 되며, 해당 변수 조합이 복잡하다면 그 조합법을 서버측에서만 알고있으면 될 일을 클라이언트 측에까지 넘기는 일이 되기 때문입니다.

    이렇게 되면, 추후 수정사항 반영시 서버측이 관리할 로직 부분의 일을 클라이언트가 처리하는 수고가 들 뿐 아니라.
    처리 후 서로간에 해당 로직을 일치시켰는지에 대한 싱크 확인 작업까지 추가되기에 서버측에서도 수고가 늘 것입니다.

    화면을 아름답고 깔끔하게 구성하는 것이 프론트 엔드 개발자의 몫이고,
    데이터 흐름을 다루는 것이 백엔드 개발자의 몫입니다.

    다만, 변수 조합이 그다지 복잡하지 않으면서 단순히 연산량이 큰 작업,
    예를들어 고사양 이미지 처리 등의 작업은 클라이언트 개발자와 상의하여 넘기는 방식으로 개발하면 좋습니다.
    서비스 연결 관계를 보았을 때, 데이터베이스 서버보다는 서비스 서버가, 서비스 서버 보다는 클라이언트 서버가 바쁜 것이 경제적이지만,
    위와 같은 예외가 존재합니다.

- 클라이언트 화면 중심 인터페이스 개발을 할 때,
    Label 데이터와 Code 데이터를 구분해야 합니다.
    예를들어, 화면에 나타나는 문구가 "예" / "아니오" 라고 하면,
    이 문구를 클라이언트 측에서 그대로 받아서 표현하면 됩니다.
    이를 Label 데이터라고 할 것입니다.
    그런데 만약 클라이언트 측에서 이 문구에 따라 화면이나 로직이 변해야 하는 상황이 온다면,
    이 Label 데이터를 이용하여,
    if(serverData = "예"){...} else {...}
    이렇게 처리를 해버린다면,
    추후 서버측에서 문구만 "맞아요" / "달라요" 라고 간단히 수정했을 때,
    클라이언트 측에서는 그와 연관된 로직을 수정해야만 하는 번거로움이 발생할 수 있습니다.
    이를 막기 위하여, Label 데이터와 의미는 동일하지만 표현 방식이 절대 변하지 않을 데이터를 보내줘야 합니다.
    위에서 예를 들자면, "예" / "아니오" 라는 데이터 외에 True, False 라는 데이터를 따로 보내주는 것입니다.
    이를 Code 데이터라 부를 것입니다.

    기획서에 따라 변수명을 설계할 때에, Code 데이터는 그냥 이름을 붙이면 되는데,
    Label 데이터는 되도록 뒤에 Label 이라고 붙여주세요.
    예를들어 매출액을 나타내는 화면이 있을 때, salesAmount 라는 변수명으로 반환하려고 합니다.
    매출액 계산을 위해 숫자로 반환할 때에는 salesAmount 라는 이름으로, 100000L 이렇게 반환하면 되며,
    화면에 표시하기 위해 문자로 반환할 때에는, salesAmountLabel 라는 이름으로, "100,000원" 이렇게 반환하는 것입니다.

- JPA 네이티브 쿼리에서
    TRUE, 혹은 FALSE 로 반환되는 변수는 매핑 객체에서 Boolean 그대로 받을 수 없고,
    Long 타입으로 받습니다. (1L == True, 0L == False)

    IF(
        join_info.uid IS NOT NULL AND
            (
                select
                count(*)
                FROM
                coverage_request
                where
                join_info_uid = join_info.uid and
                row_delete_date_str='-' and
                reject_or_payment_date is NULL
            ) >0,
            TRUE,
            FALSE
    ) AS insuranceRequest

    예를들어 위와 같이 TRUE, 혹은 FALSE 를 반환하는 변수  insuranceRequest 를 받으려면,

    interface NativeQueryOutputVo {
        var insuranceRequest: Long
    }

    이처럼 Long 으로 받도록 만들어야 합니다.

    다만, 원래 변수 타입이 Boolean(BIT(1)) 인 변수를 그대로 받거나, 혹은
    join_info.coverage_expired_date < NOW() AS insuranceExpired
    위와 같이 비교문 반환값으로 나오는 변수의 경우는 Boolean 으로 받을 수 있습니다.

- API 컨트롤러의 변수명으로는 isXXX 란 이름을 사용하지 마세요.
    예를들어, isEmpty 라는 변수명을 반환하도록 설계하였다면,
    매핑시 isEmpty 가 반환되는 것이 아니라 empty 라는 이름으로 반환이 될 것입니다.

- JPA 네이티브 쿼리에서 sum 으로 값을 더하여 가져올 때, sum 결과물이 null 이 될 수 있습니다.
    검색 데이터가 아예 없는 경우,
    그리고 nullable 타입의 컬럼에 sum 을 할 때, 검색된 결과가 모두 null 일 경우가 그러합니다.
    (하나라도 검색이 되었다면, null 부분은 0 으로 다루어 더해집니다.)
    요약하자면, sum 결과값은 Long? 으로 받으세요.

- JPA 네이티브 쿼리에서 복잡한 기능, 특정 데이터베이스 엔진의 제공 함수는 최대한 배제합시다.
    데이터베이스 엔진 변경, 버전업 등에 영향을 받을 수 있으므로 관리가 어려워집니다.

- 보안을 위하여, Rest 서버에서는 오로지 클라이언트에서만 요청을 받도록 AWS 와 같은 플랫폼 단에서 다른 요청들을 블록하도록 처리하세요.
    이렇게 되면 당연히 서버는 UI 를 제공할 수 없지만, 오히려 역할을 명확한 분담이란 측면에서 관리가 용이해집니다.

- JPA 에서 DATETIME 변수를 다룰 때는 자동으로 TimeZone 을 맞춰줍니다.
    예를들어 JPA 가 UTC, 데이터베이스가 KST 시간을 사용중이라고 했을 때,
    JPA 에서 UTC 시간인 2024-05-02 03:38:46.026 를 데이터베이스에 입력하면,
    데이터베이스에는 실제로는 KST 시간인 2024-05-02 12:38:46.026 가 저장이 되며,
    데이터베이스에서 KST 시간인 2024-05-02 12:38:46.026 를 조회하면,
    UTC 시간을 사용중인 스프링부트 시스템에 맞춰서 JPA 는,
    2024-05-02 03:38:46.026 라고 데이터를 변환해줄 것입니다.

- 혼란을 피하고 싶다면, 날짜 데이터에 타임존을 표시하는 것이 좋습니다.
    yyyy_MM_dd_'T'_HH_mm_ss_SSS_z
    위와 같은 표현 방식이라면,
    2024_05_02_T_14_22_23_272_KST
    이렇게 일시 표현이 되며,
    이를 통하여 해당 시간의 기준이 되는 타임존을 한눈에 알 수 있기에 오해를 방지할 수 있습니다.
    또한, 위에서 명확한 일시 표현을 위하여,
    yyyy-MM-dd_'T'_HH:mm:ss.SSS_z
    이련 형식을 사용할 수도 있겠지만, 일시 데이터가 파일명으로 사용될 수 있을 경우를 생각하여 분리자를 '_' 로 표현한 것이므로,
    상황에 따라 다를 테지만 거의 공통적으로 위와 같인 표현방식을 사용하면 일관성으로 인하여 편할 것이라고 생각합니다.
    년, 월, 일, 시, 분, 초, 밀리초 의 경우 어디까지 표현할지에 대한 것은 상황에 맞게 선택하세요.
    저는 보통 데이터베이스 저장시 밀리초 6자리 까지 저장하는데, 때에 따라 달라질 수도 있습니다.

- application.yml 에서,
    datasource.{데이터베이스}.jdbcUrl 에 serverTimezone 설정은 해당 데이터베이스가 사용중인 타임존을 설정하면 됩니다.
    ApplicationConstants.SYSTEM_TIME_ZONE 는 본 서버 프로젝트의 타임존 설정으로,
    이 둘을 설정했다면, 개발자는 JPA 를 사용하여 데이터베이스의 날짜 데이터를 다룰 때, 본 서버의 타임존만을 고려하면 됩니다.
    예를들어 본 서버의 타임존이 Asia/Seoul 로 설정되어있고,
    데이터베이스의 타임존은 serverTimezone=UTC 로 설정되어 있다고 합시다.
    서버 코드로 LocalDatetime.now() 로 현재 시간을 가져온다면 이는 Asia/Seoul 의 현 시간인데,
    이를 UTC 기준 데이터베이스에 입력하려면 당연히 타임존 변환 후 저장을 해야겠죠?
    만약 지금이 Asia/Seoul 기준 19시라면, UTC 기준으로는 -9시간을 하여 10시가 되는 것입니다.
    원래라면 이렇게 변환을 거쳐서 입력을 하고,
    또한 UTC 로 저장된 날짜 데이터를 조회할 때에는 +9 를 하여 다뤄야 하지만,
    JPA 에서 serverTimezone 을 설정하여 데이터베이스의 타임존을 설정해주었다면,
    입 출력시에 자동으로 변환이 됩니다.

    테스트를 하고 싶다면, 앞서 설명대로,
    ApplicationConstants.SYSTEM_TIME_ZONE 을 Asia/Seoul 로 설정하고,
    datasource.{데이터베이스}.jdbcUrl 에 serverTimezone 설정을 UTC 로 설정한 상태에서,
    API C7-N1 입력값 중 dateString 에,
    2024_05_02_T_19_00_00_000000
    을 입력해보세요.
    그리고 데이터베이스를 확인하면, 저장된 값은 KST 기준 날짜가 UTC 기준으로 변환된
    2024_05_02_T_10_00_00_000000 이 저장되어 있는 것을 볼 수 있습니다.
    반대로, API C7-N4 로 방금 저장된 날짜를 조회한다면,
    데이터베이스에는 2024_05_02_T_10_00_00_000000 로 저장되어 있지만,
    2024_05_02_T_19_00_00_000000_KST 로 받아오는 것을 확인할 수 있을 것입니다.

    주의할 점은, serverTimezone 설정은 실제 데이터베이스 설정과 동기화 되지 않습니다.
    무슨 의미냐면, 실제로 데이터베이스가 KST 시간을 써도, serverTimezone 설정을 UTC 로 적는다면,
    JPA 날짜 변환 기준은 본 서버 타임존과 serverTimezone 설정을 기준으로 한다는 것으로 이 설정을 수동으로
    데이터베이스에 맞추는 것이 중요하다는 것입니다.

    데이터베이스에서 현재 설정된 타임존을 알기 위해서는,
    select @@global.time_zone, @@session.time_zone;

    데이터베이스 타임존을 설정하기 위해서는
    SET GLOBAL time_zone='+00:00';
    SET time_zone='+00:00';

    위와 같이 입력하면 됩니다.

    추가로, serverTimezone 설정을 적지 않는다면, JPA 는 데이터베이스의 타임존이 서버 타임존과 일치한다고 간주할 것입니다.

- Swagger 에서 Enum 타입의 상수값에 대한 설명을 어노테이션으로 달 수는 없으니, 이 타입을 사용하는 변수에 따로 설명을 달아줘야 합니다.

- 제가 백엔드 개발자의 입장에서 개발을 진행하며 느꼈던, 이상적이라고 생각하는 프로젝트의 개발 진행 순서와 방식에 대해 정리하겠습니다.
    아래서 설명하는 프로젝트 개발의 진행 환경은,
    일반적인 웹 서비스 수준의 프로젝트 개발에 필수적인 포지션 별 최소한의 핵심 팀원만이 존재한다고 가정하고,
    각 분야별 상호간 업무와 책임에 대해 엄격히 분리된 상황을 가정합니다.
    즉, 개발 관련 인원은 프론트 앤드 개발자, 백엔드 개발자, 기획자, 디자이너 로 한정하였습니다.

    1. 비즈니스 관련 회의 및 개발 니즈 확인
    2. CEO, CTO, 기획자, 마케터 등 관련된 인원들의 의견을 종합하여, 니즈에 대한 구체화 회의 및 프로젝트 개발 결정 :
        각자 역할에 충실하게 회의를 진행해야 합니다.
        특히, 고객과 맞닿아 있는 마케터분은 고객의 입장에서 고객의 니즈에 중점으로 하여,
        본인이 해당 제품을 가지고 나가서 부끄러움이 없도록 의견을 강하게 어필하고,
        CTO 님은 각 아이디어가 현재 사내 기술과 자본력으로 얼마나 구현할 수 있을지 선을 그어 주셔야 하며,
        나머지분들은 각자 회사와 팀을 위하여 할수있는 한 적극적으로 아이디어를 공유하며,
        회의 참여자들은 그 누구의 의견도 경청하며 건설적인 방향으로 회의를 진행하고 결정하는 것이 좋을 것입니다.
    3. 기획자의 기획서 준비 및 개발 진행 전까지 승인받기 :
        기본 골격은 절대 변하지 않도록 확정되어야 하며,
        변경에 대한 요청이 있다면 다음 버전에야 진행하는 것으로 가정하여, 초반에 확실하게 중심을 잡아주셔야 합니다.
        기획서가 나오고 컨펌을 받은 시점부터 개발이 가능해집니다.
    4. 본격적인 개발 실행 시작 시점 :
        디자인 파트의 경우는 디자인 최종 승인자의 니즈에 맞게 디자인을 시작하면 됩니다.
            디자이너 분께서 센스가 좋으시다면,
            언제든 빠르게 대체 가능한 이미지 부분의 작업은 제외하고,
            변화가 없거나 크게 변경될 여지가 없는 프레임 부분을 먼저 만들어 배포를 하신다면 좋을 것이라 생각이 됩니다.
        백엔드 개발 파트는 데이터베이스 구조 설계, 배포 환경 준비 및 API 인터페이스 작성을 시작합니다.
            가능하면 배포 환경 준비 이후에 바로 API 인터페이스 작성을 우선시하여, 프론트 엔드에게 빠르고 정확하게 공유하도록 하세요.
            (API 문서는 프론트 엔드 개발자에게 제 2의 기획서와 같습니다.)
        프론트 엔드 개발 파트는 디자인과 서버 API 가 완료되어야 진행한다는 생각을 버리고,
            이번 기획상 프론트엔드단 에서 처리가 필요한 기술들(지도 API, OAuth2, 문서 편집기, 새로운 라이브러리 적용 등)에 대하여,
            모듈단위 함수 작성 및 테스트를 통한 적용 준비를 해주시고,
            디자인과 서버 API 가 변경될 수 있다는 가정하에,
            이 두 요소에 들어가는 노력을 최소화한 상태로 화면별 골격을 미리 만들어두면 추후 시간에 쫓기는 일이 없이 편히 진행이 가능할 것입니다.
            클라이언트 개발은 일단 개발이 진행되면 테스트 시점은 물론이고, 운영 시점까지 쉼없이 달려야 하는 파트이므로,
            이때 미리 준비해두는 것이 부하를 줄일 수 있습니다.
    5. 개발 중반 시점 :
        백엔드 API 인터페이스 작성이 빠르게 완료된 상황일 것입니다.
        더미 데이터를 반환하는 API 를 프론트엔드 개발자에게 공개한 후, 구현을 시작하는데,
        백엔드 개발자는 이때부터, 프론트 엔드 개발자의 요구에 최대한 응하며, API 수정과 구현에 힘쓰면 됩니다.
        디자이너 분께서는 디자인 초안이 완료되었을 수도 있고 아닐 수도 있습니다.
        제 경험상으로는 완료되었을 가능성이 높으므로, 그러한 상황이라면 프론트 엔드 개발자분에게 빠르게 공유하시고 작업을 재개하면 좋습니다.
        프론트 엔드 개발자분께서는 백엔드 API 및 디자인 초안이 완료되었다면 본격적으로 작업을 개시하면 됩니다.
        백엔드 API 인터페이스는 무조건 준비된 상황이므로, 만약 디자인 초안이 없더라도 작업량이 없지는 않을 것입니다.
    6. 개발 후반 시점 :
        이 시점에 백엔드 API 구현 부분이 끝이 날 것입니다.
        디자인 작업의 경우도 끝이 났을 수도 있고 아닐 수도 있는데, 작업을 계속해주시고,
        남은 것은 프론트 엔드 개발의 완료를 기다리는 것 뿐입니다.
    8. 테스트 :
        가장 마지막에 작업이 완료되는 프론트 엔드 개발 작업의 완성 기준으로 테스트가 진행됩니다.
        프로젝트 시작 전, 상정해 두었던 프로젝트 개발 시간이 존재할 때,
        프론트 엔드 개발 완료가 그보다 빠르게 끝난다면, 바로 테스트에 들어갈 필요가 없이,
        프론트엔드 개발자 본인의 프로젝트에 주석 처리, 코드 정리 등 리펙토링 및 자체검증을 할 시간을 주는 것이 좋습니다.
        이제 테스트를 진행하면 되는데,
        테스트 전담/전문 팀이 존재하면 좋지만, 만약 없다고 한다면,
        테스트 진행 책임자를 한명 두고, 클라이언트를 제외한 나머지 개발팀원이 테스트 진행자의 지시하에 테스트를 진행하면 됩니다.
    7. 남는 시간 :
        위와 같은 프로세스에서 가장 빠르게 작업이 완료되는 순서를 보자면,
        기획자, 백엔드 개발자, 디자이너, 프론트 엔드 개발자
        위와 같은 순서입니다.
        프론트엔드 개발자는 처음부터 끝까지 개발에만 힘을 쓰면 되며,
        기획자의 경우는 특성상 프로젝트 총괄과 같은 작업을 맡은 것이므로,
            일정 관리, 개발 외적인 압력 조율, 개발팀간 발생할 수 있는 의견 충돌에 대한 판결 등을 맡아주시면 되며,
            이러한 역할의 특성상, 기획자가 프로젝트 리더 역할을 한다면 누구보다 좋은 포지션이라 생각됩니다.
            테스트 역시, 진행 책임 적임자가 따로 없다면, 전체 플로우를 누구보다 잘 알고 있는 기획자가 맡는 것이 좋으며,
            이렇듯, 기획서 작성이라는 작업 외에도 프로젝트의 처음에서 끝까지 가장 핵심적인 역할을 하기에,
            공식 리더가 아니라도 모든 개발 팀원은 기획자의 의견을 최대한 존중해야만 합니다.
        디자이너의 경우는,
            완전 전문 외라서 전혀 모르겠습니다만,
            프론트 엔드 개발에 큰 부담을 주지 않는 영역에서 여러 시도를 하고 개선을 하는 것도 좋을 것 같습니다.
            예를들어, 어떠한 화면의 프레임 순서나 애니메이션을 변경하는 것이 아니라,
            프레임 내의 그림을 변경하는 것, 글자 크기를 조금 변경하는 것, 색상만 변경하는 것 정도의 변화는,
            프론트 엔드 개발 시간에도 크게 영향을 끼치는 것이 아닙니다.
            그리고, 테스트 진행시에는 꼭 참여를 하는 것을 권장합니다.
            로직을 모른다는 가정하에, 가장 일반적인 사용자들과 동일한 관점에서 테스트가 가능할 것입니다.
        백엔드 개발자의 경우는,
            API 구현이 끝난 상태에서는 코드 리펙토링과, 경우에 따라 추후 복잡해질 수 있는 부분에 대한 문서화 작업이 필요합니다.
            즉, 운영 시점을 대비해야 하는 것입니다.
            서버측의 테스트는 당연히 먼저 진행해야 합니다.
            전체 테스트 중, 클라이언트 프로그램의 에러인지 서버의 에러인지를 파악하느라 더 시간을 낭비하지 않도록,
            철저하게 서버측 에러를 먼저 모두 바로잡아버리는 것입니다.
            그 이외에는 프로젝트 리더의 지시에 따라 업무를 진행하면 됩니다.

- 팀활동에서 중요한 것은, 자기 자신의 업무를 마치는 것은 기본이며, 상호 존중은 미덕이고, 프로젝트의 성공 여부는 생명이라고 생각합시다.
    프로젝트가 실패한다면 팀 활동의 시간 자체가 가치가 없어질 수도 있으며,
    (물론, 그것을 진행하며 쌓은 노하우나 기술로 다음 도전을 할 때를 생각하면 실패 역시 무가치하지는 않지만, 성패를 가볍게 보지 말자는 것입니다.)
    자기 자신의 업무를 마치지 못한다면 자신이 팀원으로 있을 가치가 없다는 것이 되며,
    상호 존중이 없다면, 팀이 아니라 개인의 집합일 뿐입니다.
    여기서 리더가 추가로 해야할 일은, 팀원이 업무와 팀에 공헌해야만 하는 이유,
    즉 모티베이션(돈, 명예, 꿈, 목표, 두려움, 합법적 불이익 등...)을 적절히 관리해야 하는 것이고,
    팀원은 그러한 리더를 따라서 최선을 다하는 것이 제가 생각하는 이상적인 팀의 모습입니다.

- 데이터베이스는 서비스가 아니라 기록입니다 :
    데이터베이스 테이블의 정보는 알아보기 쉽게, 주제에 맞게, 중복이 없게, 무결하게 설계해야 합니다.
    그런데 간혹, 서비스를 구현하기 위해 데이터베이스를 작성하면 화면에 맞춰서 데이터베이스를 설계하고 싶은 유혹이 들 수 있습니다.
    예를들어 계약서 정보를 보여주는 화면에서, 제품 생산자 이름과 전화번호를 보여준다고 합시다.
    계약서 - 제품 - 제품 생산자 의 순서로 외래키로 연결된 서로 다른 테이블을 사용할 때,
    이러한 정보를 가져올 때에는 Join 을 2번 해야 하네요.
    데이터베이스를 서비스와 함께 설계하는 단계이므로, 귀찮게 join 을 하지 말고, 차라리 계약서 테이블에도 이 정보를 넣고 싶을 수가 있습니다.
    결론적으로 이러한 방식은 데이터 불일치의 취약점을 발생시키므로 추천하지 않습니다.
    데이터베이스는 리소스이지 서비스가 아닙니다.
    서비스를 위해 데이터베이스를 맞춘다고 생각하지 말고,
    데이터베이스 전문가가 만든 최고로 효율적인 구조의 데이터베이스 소스를 서비스에서 이용한다는 마음으로 진행을 해야 데이터베이스 구조도,
    코드 구조도 깔끔해집니다.

    실례를 하나 들자면, 제가 데이터베이스를 설계할 때, 청구서 테이블의 상태값을 데이터베이스에 저장할지 어떨지 고민했을 때가 있었습니다.
    예를들어 청구서 정보에서 접수 중, 심사 중, 보류, 지급 거절, 지급 예정(승인), 지급 완료 라는 상태가 있을 때,
    각 상태를 파악할 수 있는 다른 정보들이 이미 데이터베이스 내에 존재할 것입니다.
    이러한 정보들을 조합하여 상태를 분류하는 것인데,
    서비스에서 편하게 처리하고자 상태 값에 대한 컬럼을 추가할수도 있습니다.
    하나의 상태를 규정하기 위하여 다른 테이블 몇개를 Join 해야 하는 경우도 있으므로 불편하고 코드가 길어지는 경우도 있기에 이해는 가지만,
    이 경우, 상태값과 실제 데이터간의 불일치가 일어날 가능성이 발생하게 됩니다.
    즉, 근본적 취약점을 내포한 테이블이 되는 것이며,
    이렇게 에러가 일어날 가능성이 있는 부분을 한 두개씩 남겨두기를 반복하다가는 추후 해당 서비스는 어디서 어떻게 터질지 모르는 폭탄이 될 것이기에,
    항상 데이터베이스 중심으로 서비스 로직을 맞추는 것을 기본으로 합시다.