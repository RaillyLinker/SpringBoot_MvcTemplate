[Dev Life Tips]
- 트랜젝션 사용 API 를 비동기 실행시 오작동을 할 수 있습니다.
    예를들어 A 테이블의 a 컬럼이 null 이 아닌지 확인하고 null 이 아니라면 값을 입력하는 api 를 동시에 요청받았을 때,
    이는 서로 다른 두 스레드에서 동시 실행이 되며, 실행하는 도중에는 트랜젝션 내에서 동작하므로, 두 요청 모두 null 체크를 통과한 상태로 진행을 하게 될 것입니다.
    이러한 경우를 방지하려면 데이터베이스에 락을 걸어두면 됩니다.

- API 컨트롤러의 변수명으로는 isXXX 란 이름을 사용하지 마세요.
    예를들어, isEmpty 라는 변수명을 반환하도록 설계하였다면,
    매핑시 isEmpty 가 반환되는 것이 아니라 empty 라는 이름으로 반환이 될 것입니다.

- API 입력값 중, 스웨거에서 (query) 라고 표시되는 쿼리 파라미터가 Nullable 일 때,
    이를 null 로 Request 하시려면 아예 파라미터 키까지 보내지 않으시면 됩니다.
    예를들어, "keyword" 라는 파라미터가 Nullable 이라면,

    http://127.0.0.1/test?keyword=hello

    이렇게 쿼리 파라미터의 값을 보낼 수 있는데,

    http://127.0.0.1/test

    이렇게 키워드 자체가 없는 상태로 요청을 하신다면 스프링부트 API 에서 "keyword" 파라미터의 변수가 null 이 왔다고 인식을 할 것입니다.

    추가로, Form 파라미터 역시 Nullable 이라면,

    curl -X 'POST' \
        'http://127.0.0.1:8080/service1/tk/v1/request-test/post-request-x-www-form-urlencoded' \
        -H 'accept: application/json' \
        -H 'Content-Type: application/x-www-form-urlencoded' \
        -d 'requestFormStringList=testString1,testString2&requestFormDouble=1.1&requestFormString=testString&requestFormBoolean=true&requestFormInt=1'

    위와 같은 방식으로 -d 부분에 데이터를 입력할 때, 키워드까지 생략하면 되며,

    Json String 을 보내는 RequestBody 의 경우에는 변수가 nullable 이라면,

    {"keyword" : null}

    이렇게 보내주시면 됩니다.

- 동일 데이터베이스 내의 서로 다른 스키마간에는 외래키 설정이 불가능합니다.
    고로, 데이터베이스 설계시 되도록 스키마를 나누지 말고, 회사 이름의 스키마를 생성하여 사용하는 것을 추천합니다.

- SQL 쿼리 작성 권장사항
    제 코드 작성 우선순위는, 가독성과 유지보수성이 1순위고, 그 외에는 상황에 따라 달라집니다.
    쿼리 작성 우선순위 역시 동일합니다.

    제 기준의 쿼리 작성 규칙을 정리하자면,

    1. 쿼리문은 서브쿼리를 최대한 줄이고, Join 역시 할 수 있다면 줄이자.
    2. 특히 From, Join 내에서 서브쿼리를 사용하는 것은 최대한 피하자.

    위와 같습니다.

    1 번 규칙은 앞서 말한 가독성과 성능을 위한 것이고,

    2 번 규칙은, 제 경험상 JOIN 문 부분에 서브쿼리를 사용했을 때,
    데이터베이스 종류에 따라 에러 발생의 원인이 될 수 있는 부분이기에 무엇보다 주의해야 합니다.
    굳이 사용해야 하는 일이 있다면 반드시 테스트를 하는 것이 필수입니다.

    물론 위와 같은 규칙들은 절대적인 것이 아니므로 상황에 따라 최선의 방법을 사용합시다.

- 데이터베이스 성능 향상 순서
    1. 쿼리문 최적화
    2. Redis 를 이용한 정보 조회 캐싱
    3. 마스터, 슬레이브 구조로 데이터베이스 분산

- Springboot Api Request Parameter 주의사항
    1. Request Query 나 FormData 로 Object 타입을 받을 수 없습니다.
        Object 타입의 경우는 그냥 분리해서 일반 타입들로 받는 방식을 사용할 수는 있는데,
        Object 단위로 묶지 못하기에 Object List 를 받는 것은 불가능하다 봐야 합니다.
        Multipart Form Data 의 MultipartFile 과 함께 Object List 를 받아야 하는 것과 같은 불가피한 상황이 온다면,
        Object List 를 JsonString 으로 받아서 파싱하는 방법을 사용하세요.
    2. Request Body 로는 Object, Object 리스트 전부 받을 수 있습니다.

- Springboot 의 각 api 는 요청시마다 독립적인 스레드가 할당됩니다.
    (테스트 api 2-13 을 실행시킨 상태에서 다른 api 를 호출하여 이를 확인할 수 있습니다.)
    즉, 비동기적으로 실행된다는 것이고, 이에 따라 각 스레드별 공유하는 전역 데이터를 사용시에는 데이터의 무결성이 깨질 수 있다는 것에 주의해야 합니다.
    JPA 와 같은 데이터베이스 ORM 프레임워크를 사용시에는 데이터베이스 접근이 블로킹되도록 처리가 되어있을텐데,
    전역 변수와 같은 것을 사용시에는 주의하세요.
    참고로, Springboot WebFlux 에서 JPA 를 사용하지 않는 이유가, JPA 의 블로킹 처리가 WebFlux 의 논 블로킹의 장점을 상쇄하기 때문이라고 알아둡시다.