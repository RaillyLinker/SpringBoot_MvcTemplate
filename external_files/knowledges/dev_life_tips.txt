[Dev Life Tips]
- 본 설명글은 경험으로 쓰여진 팁입니다.
    실제 제가 프로젝트를 주도하거나 참여하며 개발하고 개선했던 사례 중,
    기록하고 곱씹으면 좋겠다고 생각한 경험을 정리한 글로,
    이미 알고 있는 내용이라도, 한번쯤 읽어보고 환기하면 좋을 것이라 생각합니다.

- 트랜젝션 사용 API 를 비동기 실행시 오작동을 할 수 있습니다.
    예를들어 A 테이블의 a 컬럼이 null 이 아닌지 확인하고 null 이 아니라면 값을 입력하는 api 를 동시에 요청받았을 때,
    이는 서로 다른 두 스레드에서 동시 실행이 되며, 실행하는 도중에는 트랜젝션 내에서 동작하므로, 두 요청 모두 null 체크를 통과한 상태로 진행을 하게 될 것입니다.
    이러한 경우를 방지하려면 데이터베이스에 락을 걸어두면 됩니다.

- 데이터베이스에서 Nullable 컬럼에는 Unique 제약을 하지 마세요.
    예를들어 Nullable 컬럼인 a 와 b 를 합성 Unique 로 설정했을 때,
    a 를 null 로 하고, b 를 2 로 입력하고,
    다음에 또 a 를 null 로 하고 b 를 2 로 입력했을 때, 이것이 차단될 것이라고 생각하겠지만, null 이 들어간 순간 unique 제약은 동작을 하지 않고,
    이상 없이 값이 들어갈 것입니다.
    꼭 입력해야 한다면, 실제 변수는 not null 로 두고, null 에 해당하는 기본값을 정해놓아 사용하면 됩니다.

- JPA 네이티브 쿼리에서
    TRUE, 혹은 FALSE 로 반환되는 변수는 매핑 객체에서 Boolean 그대로 받을 수 없고,
    Long 타입으로 받습니다. (1L == True, 0L == False)

    IF(
        join_info.uid IS NOT NULL AND
            (
                select
                count(*)
                FROM
                coverage_request
                where
                join_info_uid = join_info.uid and
                row_delete_date_str='/' and
                reject_or_payment_date is NULL
            ) >0,
            TRUE,
            FALSE
    ) AS insuranceRequest

    예를들어 위와 같이 TRUE, 혹은 FALSE 를 반환하는 변수  insuranceRequest 를 받으려면,

    interface NativeQueryOutputVo {
        var insuranceRequest: Long
    }

    이처럼 Long 으로 받도록 만들어야 합니다.(참 : 1, 거짓 : 0)

    다만, 원래 변수 타입이 Boolean(BIT(1)) 인 변수를 그대로 받거나, 혹은
    join_info.coverage_expired_date < NOW() AS insuranceExpired
    위와 같이 비교문 반환값으로 나오는 변수의 경우는 Boolean 으로 받을 수 있습니다.

- API 컨트롤러의 변수명으로는 isXXX 란 이름을 사용하지 마세요.
    예를들어, isEmpty 라는 변수명을 반환하도록 설계하였다면,
    매핑시 isEmpty 가 반환되는 것이 아니라 empty 라는 이름으로 반환이 될 것입니다.

- JPA 네이티브 쿼리에서 sum 으로 값을 더하여 가져올 때, sum 결과물이 null 이 될 수 있습니다.
    검색 데이터가 아예 없는 경우,
    그리고 nullable 타입의 컬럼에 sum 을 할 때, 검색된 결과가 모두 null 일 경우가 그러합니다.
    (하나라도 검색이 되었다면, null 부분은 0 으로 다루어 더해집니다.)
    요약하자면, sum 결과값은 Long? 으로 받으세요.

- JPA 네이티브 쿼리에서 복잡한 기능, 특정 데이터베이스 엔진의 제공 함수는 최대한 배제합시다.
    데이터베이스 엔진 변경, 버전업 등에 영향을 받을 수 있으므로 관리가 어려워집니다.

- JPA 에서 DATETIME 변수를 다룰 때는 자동으로 TimeZone 을 맞춰줍니다.
    예를들어 JPA 가 UTC, 데이터베이스가 KST 시간을 사용중이라고 했을 때,
    JPA 에서 UTC 시간인 2024-05-02 03:38:46.026 를 데이터베이스에 입력하면,
    데이터베이스에는 실제로는 KST 시간인 2024-05-02 12:38:46.026 가 저장이 되며,
    데이터베이스에서 KST 시간인 2024-05-02 12:38:46.026 를 조회하면,
    UTC 시간을 사용중인 스프링부트 시스템에 맞춰서 JPA 는,
    2024-05-02 03:38:46.026 라고 데이터를 변환해줄 것입니다.

- 혼란을 피하고 싶다면, 날짜 데이터에 타임존을 표시하는 것이 좋습니다.
    yyyy_MM_dd_'T'_HH_mm_ss_SSS_z
    위와 같은 표현 방식이라면,
    2024_05_02_T_14_22_23_272_KST
    이렇게 일시 표현이 되며,
    이를 통하여 해당 시간의 기준이 되는 타임존을 한눈에 알 수 있기에 오해를 방지할 수 있습니다.
    또한, 위에서 명확한 일시 표현을 위하여,
    yyyy-MM-dd_'T'_HH:mm:ss.SSS_z
    이련 형식을 사용할 수도 있겠지만, 일시 데이터가 파일명으로 사용될 수 있을 경우를 생각하여 분리자를 '_' 로 표현한 것이므로,
    상황에 따라 다를 테지만 거의 공통적으로 위와 같인 표현방식을 사용하면 일관성으로 인하여 편할 것이라고 생각합니다.
    년, 월, 일, 시, 분, 초, 밀리초 의 경우 어디까지 표현할지에 대한 것은 상황에 맞게 선택하세요.
    저는 보통 시간 저장시 밀리초 3자리 까지 저장하는데, 때에 따라 달라질 수도 있습니다.

- application.yml 에서,
    datasource.{데이터베이스}.jdbcUrl 에 serverTimezone 설정은 해당 데이터베이스가 사용중인 타임존을 설정하면 됩니다.
    ApplicationConstants.SYSTEM_TIME_ZONE 는 본 서버 프로젝트의 타임존 설정으로,
    이 둘을 설정했다면, 개발자는 JPA 를 사용하여 데이터베이스의 날짜 데이터를 다룰 때, 본 서버의 타임존만을 고려하면 됩니다.
    예를들어 본 서버의 타임존이 Asia/Seoul 로 설정되어있고,
    데이터베이스의 타임존은 serverTimezone=UTC 로 설정되어 있다고 합시다.
    서버 코드로 LocalDatetime.now() 로 현재 시간을 가져온다면 이는 Asia/Seoul 의 현 시간인데,
    이를 UTC 기준 데이터베이스에 입력하려면 당연히 타임존 변환 후 저장을 해야겠죠?
    만약 지금이 Asia/Seoul 기준 19시라면, UTC 기준으로는 -9시간을 하여 10시가 되는 것입니다.
    원래라면 이렇게 변환을 거쳐서 입력을 하고,
    또한 UTC 로 저장된 날짜 데이터를 조회할 때에는 +9 를 하여 다뤄야 하지만,
    JPA 에서 serverTimezone 을 설정하여 데이터베이스의 타임존을 설정해주었다면,
    입 출력시에 자동으로 변환이 됩니다.

    테스트를 하고 싶다면, 앞서 설명대로,
    ApplicationConstants.SYSTEM_TIME_ZONE 을 Asia/Seoul 로 설정하고,
    datasource.{데이터베이스}.jdbcUrl 에 serverTimezone 설정을 UTC 로 설정한 상태에서,
    API C7-N1 입력값 중 dateString 에,
    2024_05_02_T_19_00_00_000
    을 입력해보세요.
    그리고 데이터베이스를 확인하면, 저장된 값은 KST 기준 날짜가 UTC 기준으로 변환된
    2024_05_02_T_10_00_00_000 이 저장되어 있는 것을 볼 수 있습니다.
    반대로, API C7-N4 로 방금 저장된 날짜를 조회한다면,
    데이터베이스에는 2024_05_02_T_10_00_00_000 로 저장되어 있지만,
    2024_05_02_T_19_00_00_000_KST 로 받아오는 것을 확인할 수 있을 것입니다.

    주의할 점은, serverTimezone 설정은 실제 데이터베이스 설정과 동기화 되지 않습니다.
    무슨 의미냐면, 실제로 데이터베이스가 KST 시간을 써도, serverTimezone 설정을 UTC 로 적는다면,
    JPA 날짜 변환 기준은 본 서버 타임존과 serverTimezone 설정을 기준으로 한다는 것으로 이 설정을 수동으로
    데이터베이스에 맞추는 것이 중요하다는 것입니다.

    데이터베이스에서 현재 설정된 타임존을 알기 위해서는,
    select @@global.time_zone, @@session.time_zone;

    데이터베이스 타임존을 설정하기 위해서는
    SET GLOBAL time_zone='+00:00';
    SET time_zone='+00:00';

    위와 같이 입력하면 됩니다.

    추가로, serverTimezone 설정을 적지 않는다면, JPA 는 데이터베이스의 타임존이 서버 타임존과 일치한다고 간주할 것입니다.

- Swagger 에서 Enum 타입의 상수값에 대한 설명을 어노테이션으로 달 수는 없으니,
    이 타입을 사용하는 변수 부분의 설명에 Enum 각 상수에 대한 설명을 달아줘야 합니다.

- SQL 쿼리 작성 권장사항
    제 코드 작성 우선순위는, 가독성과 유지보수성이 1순위고, 그 외에는 상황에 따라 달라집니다.
    쿼리 작성 우선순위 역시 동일합니다.

    제 기준의 쿼리 작성 규칙을 정리하자면,

    1. 쿼리문은 서브쿼리를 최대한 줄이고, Join 역시 할 수 있다면 줄이자.
    2. 특히 From, Join 내에서 서브쿼리를 사용하는 것은 최대한 피하자.

    위와 같습니다.

    1 번 규칙은 앞서 말한 가독성과 성능을 위한 것이고,

    2 번 규칙은, 제 경험상 JOIN 문 부분에 서브쿼리를 사용했을 때,
    데이터베이스 종류에 따라 에러 발생의 원인이 될 수 있는 부분이기에 무엇보다 주의해야 합니다.
    굳이 사용해야 하는 일이 있다면 반드시 테스트를 하는 것이 필수입니다.

    물론 위와 같은 규칙들은 절대적인 것이 아니므로 상황에 따라 최선의 방법을 사용합시다.

- 데이터베이스 성능 향상 순서
    1. 쿼리문 최적화
    2. Redis 를 이용한 정보 조회 캐싱
    3. 마스터, 슬레이브 구조로 데이터베이스 분산

- API 설계 방침
    데이터베이스에는 Long 타입으로 가격 정보가 100000 이라고 저장된 경우를 가정해봅시다.

    이 데이터를 가지고 화면에 표시하는 작업을 위해 프론트 엔드 개발자에게 정보를 전달해야만 하는데,

    프론트엔드 개발자의 개발 스타일에 따라, 어떤 분은 100000 의 숫자 데이터를 보내달라고 하기도 하고,
    어떤 분은 "100,000원" 과 같이 화면에 표현되는 형태로 가공하여 전달해달라고 하는 경우도 있습니다.

    전자를 Code 반환 방식이라고 하고,
    후자를 Label 반환 방식이라고 하겠습니다.

    Code 반환 방식은, 화면의 표현 방식에 구애받지 않는 '의미'를 전달하는 방법이고,
    Label 반환 방식은, 화면의 문자열 표현 방식까지 서버에서 가공하여 전달하는 방법이죠.

    과연 어떻게 보내주는 것이 옳을까요?

    결론적으로 말하자면, Code 반환 방식이 더 좋습니다.

    비교를 위하여 두 방식의 장단점을 나열하겠습니다.

    Code 반환 방식 장점
    1. 의미를 지닌 최소한의 데이터를 반환하므로, 네트워크 이동 데이터량을 줄일 수 있다.
    2. 데이터 가공에 들어가는 연산량을 아낄 수 있다.
    3. 특정 화면에 종속된 것이 아니기에, API 의 재활용성이 좋아진다.

    Code 반환 방식의 단점
    1. 서버 로직을 클라이언트 개발자에게 떠넘길 가능성이 있습니다.

        예를들어 특정 상품의 '상태'는, 3가지 종류가 있다고 가정하겠습니다.
        그런데 그러한 상태를 파악하기 위하여 관련된 변수 10 개를 조합해야 한다고 가정했을 때,

        변수 10 개를 그대로 클라이언트 개발자에게 반환하여 이를 조합하여 상태를 판단하라고 하면 어떤 일이 일어날까요?

        클라이언트 개발자는 변수 조합을 '공부' 해야 할 것입니다.

        이는 단순히 클라이언트 개발자의 수고가 느는 것 뿐 아니라,
        서버측 입장에서도 추후 해당 상태 파악을 위한 기준이 바뀌었을 때,
        이를 일일이 클라이언트 개발자에게 공유해야 합니다.

        이렇게 된다면 서버측에서만 관리해야할 일을 클라이언트 개발자에게 떠넘기는 격이 되며,
        나중에는 서버측의 사소한 로직 변경이 클라이언트측 에러의 원인이 될 수 있기에,
        서버 개발자의 경우에도, 서버 로직 변경뿐 아니라 클라이언트 싱크도 신경써야 하는 수고가 느는 것입니다.
        (이러한 경우에는 변수 조합에 따른 상태 코드를 정리해서 클라이언트에 넘겨주는 가공을 해야합니다.)

    2. 1번의 이유로 인하여 API 설계에 신중을 기해야 하고, 문서화가 필수이며, 특히 클라이언트 개발자와 적극적인 의사소통이 필요합니다.

    Label 반환 방식 장점
    1. 서버에서 받은 문자 데이터를 그대로 화면에 뿌려주는 것으로, 변환 로직 작성 작업을 줄일 수 있다.
    2. 화면의 문자 데이터의 표현 방식 변경시 서버에서만 신경쓰면 된다.
    3. 경험상, 프론트엔드 개발자와의 마찰을 줄일 수 있다.

    Label 반환 방식의 단점
    1. 앞서 언급했듯, 라벨 데이터는 화면에 표시되는 '문자'에 한정되고, 그외에는 여전히 코드 데이터를 혼합해야합니다.

    2. 서버에 UI 영역을 떠넘기는 격입니다.
        특히, 다국어 처리를 가정해봅시다.
        다국어 처리는 각 언어를 잘 아는 각 담당의 클라이언트 개발자가 처리해야할 부분인 것이지,
        서버측에서 이를 처리한다고 하면 프론트엔드와 백엔드를 나누는 이유가 없어지는 것입니다.

    3. Code 반환 방식의 모든 장점에 역행합니다.

    위와 같은 장단점을 비교하였을 때,
    저는 Code 반환 방식이 보다 이치에 맞다고 봅니다.
    서버는 항상 클라이언트보다 소수일 수 밖에 없습니다.

    연산량과 데이터량을 줄이는 것은 서버의 중요한 과제이고,
    Label 반환 방식의 장점인 문자 데이터의 표현 방식(UI)의 경우는 서버측이 담당해야 할 것이 아니라,
    클라이언트가 담당할 부분입니다.

    또한, 표현 방식을 서버에서 변경해주는 것은 그리 큰 문제는 아니기에 서버에서 담당해도 무리가 없겠지만,
    Rest API 를 구현한 서버 프로그램은 서로 다른 여러 프로젝트의 클라이언트들이 사용을 할 수 있습니다.
    표현 방식 같은 사소한 부분의 업데이트를 위하여,
    해당 서버를 바라보는 다른 모든 클라이언트의 서비스를 중단해야 한다는 것은 문제가 있는 구조이며,

    Label 반환 방식에서 코드 데이터를 받지 않는 것도 아닙니다.
    Label 데이터는 그대로 화면에 뿌려주기 위한 데이터로 사용되며,
    기능 구현시 조건문의 조건으로 사용할 때에는, 표현법이 변경될 가능성이 있는 Label 데이터를 보내주는 것이 아니라,
    변하지 않는 Code 데이터를 보내주어야 하기 때문이며,
    Label 데이터라 하더라도 문자 데이터 한정으로,
    아이콘이나 색상 등의 문자 이외의 화면 표시는 또한 Code 데이터를 사용해야만 합니다.
    어떤 것은 Label 로 보여주고, 어떤 것은 Code 로 보내주는 이러한 통일성 없는 설계는 분명 지양해야 할 것입니다.

    위와 같은 견해로 인하여,
    저는 Code 반환 방식의 단점 중, 클라이언트에 서버 로직을 떠넘기는 것만 제대로 막을 수 있다면,
    Code 반환 방식을 사용하는 것이 더 나은 방식이라 생각합니다.

- API 입력값 중, 스웨거에서 (query) 라고 표시되는 쿼리 파라미터가 Nullable 일 때,
    이를 null 로 Request 하시려면 아예 파라미터 키까지 보내지 않으시면 됩니다.
    예를들어, "keyword" 라는 파라미터가 Nullable 이라면,

    http://127.0.0.1/test?keyword=hello

    이렇게 쿼리 파라미터의 값을 보낼 수 있는데,

    http://127.0.0.1/test

    이렇게 키워드 자체가 없는 상태로 요청을 하신다면 스프링부트 API 에서 "keyword" 파라미터의 변수가 null 이 왔다고 인식을 할 것입니다.

    추가로, Form 파라미터 역시 Nullable 이라면,

    curl -X 'POST' \
        'http://127.0.0.1:8080/service1/tk/v1/request-test/post-request-x-www-form-urlencoded' \
        -H 'accept: application/json' \
        -H 'Content-Type: application/x-www-form-urlencoded' \
        -d 'requestFormStringList=testString1,testString2&requestFormDouble=1.1&requestFormString=testString&requestFormBoolean=true&requestFormInt=1'

    위와 같은 방식으로 -d 부분에 데이터를 입력할 때, 키워드까지 생략하면 되며,

    Json String 을 보내는 RequestBody 의 경우에는 변수가 nullable 이라면,

    {"keyword" : null}

    이렇게 보내주시면 됩니다.

- 제 프로젝트의 데이터베이스 테이블은 논리적 삭제 대신 물리적 삭제를 선호합니다.
    먼저, 논리적 삭제를 사용할 때의 장단점을 나열하겠습니다.

    장점
    1. 삭제 처리에 대한 안전성 제공
    2. 일종의 히스토리 기능 수행

    단점
    1. 코드, 쿼리 및 테이블 구조 복잡성 증가
    2. 외례키 관련 삭제 검증 기능 지원을 못받음
    3. 쓸데없는 데이터가 쌓여가므로 클리너를 만들고 주기적으로 데이터 정리를 해줘야만 함

    위와 같습니다.

    저는 장점보다 단점이 더 크다고 판단하였습니다.

    판단의 근거를 나열하겠습니다.

    1. 제 경험상 논리적 삭제를 적용했을 때 그리 큰이득을 보지 못했습니다.
    2. 클리너를 사용하여 공간 절약을 하려고 한다면,
        논리적 삭제된 데이터에 대한 클리너 생성에 들어가는 노력과 시간,
        데이터베이스 테이블이 수정될 때마다 클리너를 수정해야 하는데에 들어가는 노력과 시간이 무시할 수준을 뛰어넘습니다.
        특히 외례키로 테이블 상호간 연관관계가 복잡하게 얽혀있을수록 더더욱 수고가 커지죠.
        그리고 결국은 물리적 삭제를 행하게 되는 클리너 코드의 실행 리스크는 물리적 삭제를 적용할 때의 단점을 그대로 가지게 됩니다.
    3. 클리너를 사용하지 않는다고 한다면, 데이터 저장 공간의 낭비는 서비스가 커지고 활성화될 수록 커집니다.
    4. 논리적 삭제의 히스토리 기능은 부가기능일 뿐이고, 정말 히스토리가 필요하다고 판단되는 테이블의 경우는 따로 히스토리 테이블을 만들면 됩니다.

    위와 같은 이유로 저는 물리적 삭제를 선호합니다.

- Thymeleaf html 의 style 태그 안에서 변수를 가져다 쓰려면,

    <style>
        /* inline css Thymeleaf 변수 사용 예시 */
        body {
            background-color: [(${viewModel.env} == 'local8080' ? '#277cea' : '#FFFFFF')];
        }
    </style>

    이렇게 하면 되며,

    태그 속성 값으로 넣을 때는,

    <span th:text="${viewModel.env}">dev</span>

    태그 내용으로 넣을 때는,

    <p>[[${message}]]</p>

    script 태그 안에서는,

    // inline javascript Thymeleaf 변수 사용 예시
    var env = "[[${viewModel.env}]]";
    alert(env);

    이렇게 하면 됩니다.

- 데이터베이스 스키마중 railly_linker_company 라고 되어있는 것은 사내 데이터베이스를 가정한 것입니다.
    사내 서비스에 사용할 정보를 저장할 스키마로,
    사원들만을 위한 회원 테이블 등을 저장하여 사용할 것입니다.

    그리고 service1 이라고 되어 있는 것은 앞으로 만들게될 서비스 프로젝트를 의미하는 것으로,
    서비스에 기본적으로 존재해야 할 계정 정보 테이블들을 구현해놓은 것입니다.

- JVM 메모리 누수 방지를 위한 체크
    1. Static 메모리 사용을 주의하세요.
        Static 영역에 작성한 변수와 데이터는 프로그램의 처음과 끝까지 사라지지 않습니다.
        이 영역의 사용을 지양하도록 합시다.

    2. 해제를 전제로 만들어진 라이브러리를 사용할 때에는 꼭 사용 후 해제하도록 합시다.
        해제가 필요한 대표적인 클래스
        PrintStream
        FileInputStream
        FileOutputStream
        BufferedReader
        InputStreamReader

    3. 래핑 클래스 구현시 로직상 메모리 해제 처리를 합시다.
        대표적인 예로, Stack 클래스를 구현할 때,
        내부적으로는 데이터의 배열이 존재하고, push 때에는 데이터를 추가하고,
        pop 때에는 데이터를 반환 및 제거를 해야하는데,
        pop 을 하여 데이터를 반환 후 제거 처리를 하지 않으면, 늘어난 데이터가 줄어들지 않고 남아있습니다.
        (덮어써질 지언정 한번 늘어난 리스트는 두번다시 줄어들지 않음.)
        이는 오작동이 아니라 정상 동작이지만 구현 실수라고 할 수 있습니다.

    4. 내부 클래스 사용을 주의합시다.
        클래스 안에 클래스를 만드는 기능은 클래스의 정리에 도움이 되지만 주의해야 합니다.
        예를 들어 클래스 안에 내부 클래스를 만들었고, 해당 내부 클래스를 다른 클래스에서 참조하여 이것이 메모리상 잔류하면,
        해당 내부 클래스를 품고 있는 부모 클래스의 데이터까지 통째로 메모리에 남게 됩니다.
        만약 내부 클래스를 사용하려면, 해당 클래스를 되도록 외부에서 사용하지 못하게 하고, 사용한다면 메모리 해제에 주의를 해야합니다.
        그게 아니라 단순히 클래스 위치 정리를 위해서라면 내부 클래스가 아닌 중첩 클래스를 사용하세요.
        중첩 클래스 역시 클래스 안에 선언하는 클래스인데, 다른점으로는, 클래스의 이름만을 빌리는 것입니다.
        kotlin 에서는 클래스 내에 단순히 클래스를 선언하면 이것이 중첩 클래스고, 내부 클래스를 만들려면 class 앞에 inner 를 붙여야 합니다.
        내부 클래스와 중첩 클래스의 차이는,

        중첩 클래스 :
        class Outer {
            val outerProperty = "Outer property"
            class Nested {
                fun nestedFunction() = "Nested function"
            }
        }

        내부 클래스 :
        class Outer {
            val outerProperty = "Outer property"
            inner class Inner {
                fun innerFunction() = "Inner function, accessing: $outerProperty"
            }
        }

        위와 같이 중첩 클래스는 단순히 이름만을 빌리는 것이므로 외부 클래스의 변수에 접근하지 못하고,
        내부 클래스는 접근이 가능합니다.

    5. Map 타입 변수 사용시에는 주의합시다.
        예를 들어보겠습니다.

        HashMap<Integer, String> hashMap = new HashMap<Integer, String>();
        Integer key = new Integer(1);
        hashMap.put(key, "1");
        key = null;
        while (true) {
        	System.out.println(hashMap);
        	System.gc();
        	if (hashMap.size() == 0) {
        		break;
        	}
        }

        위와 같이 HashMap 을 사용하는 코드를 봅시다.
        Integer 타입의 key 변수가 있고,
        map 의 key 로 key 변수를 입력하였습니다.
        이렇게 한다면 hashMap 에 해당 키를 사용하면 그 값이 "1" 에 접근이 가능하겠죠?
        그런데 바로 다음 줄에 key 변수를 null 로 만들어서 해당 값에 접근 자체를 불가능하게 만들었습니다.
        이렇게 된다면 hashMap 의 "1" 이라는 값에는 어떻게 하든 접근이 불가능해지기에 메모리상 쓸모없는 데이터가 잔류하게 되는 것이죠.
        이러한 쓸모없는 데이터를 정리하기 위해 존재하는 JVM GC 이지만 정작 이를 인지하지 못합니다.
        위 코드에서 hashMap 의 사이즈가 계속해서 1로 유지되기 때문에, while 문에서 빠져나가지 못하게 될 것입니다.

        이것이 첫번째 문제점입니다.
        map 에 저장된 데이터는 접근이 불가능해져도 정리되지 않습니다.

        위 코드의 경우에는 HashMap 이 아닌 WeakHashMap 을 사용하면 해결이 됩니다.
        WeakHashMap 객체를 사용한다면 GC 의 대상이 된다고 이해합시다.

        다음 문제점으로는,
        위와 같은 경우는 key 를 접근 불가로 만드는 경우에 발생하는 문제이므로 애초에 key 를 not nullable 로 바꾸면 됩니다.

        그보다 더 일반적으로 나타날 수 있는 실수가 존재하는데,
        map 안에 데이터를 저장하고, 개발자 스스로가 필요 없다고 판단할 수 있는 시점에도 해당 데이터를 remove 하지 않은 경우가 해당됩니다.
        이는 특별한 오동작이 아니라 논리적인 정상 동작이지만 단지 실수할 가능성이 높은 케이스입니다.
        map 안의 데이터는 언제든 접근이 가능하도록 설계되어 있으므로 map 안에 저장된 모든 데이터는 자동으로 지워지지 않으며,
        만약 개발자가 코드상 더이상 사용되지 않는다고 여기는 데이터가 있다면 map 에서 스스로 제거하도록 처리 합시다.

        마지막으로 주의해야 할 점으로는,
        key 의 경우는 되도록 object 타입 변수가 아닌 기본 타입 변수를 사용할 것이며,
        만약 object 타입을 사용한다면 class 의 equals 와 hashCode 메소드를 꼭 구현하여 다른 변수와 구분이 가능하도록 하세요.

        이상입니다.

- 리스트 타입의 종류
    List :
        변경이 불가능한 리스트입니다.

    MutableList :
        MutableList 는 Kotlin 의 인터페이스로, 변경 가능한 리스트를 나타냅니다.
        반대되는 개념으로는, 변경이 불가능한 그냥 List 타입이 있습니다.
        이는 인터페이스이므로 특정한 구현체에 의존하지 않으며, 여러 구현체가 존재할 수 있습니다.
        대표적인 구현체로는 ArrayList 와 LinkedList 등이 있습니다.
        만약 mutableListOf() 함수로 객체를 초기화 한다면 ArrayList 가 생성될 것입니다.

    ArrayList :
        MutableList 의 일종입니다.
        내부적으로 배열을 사용하여 요소를 저장하는 리스트 구현체로,
        ArrayList 는 O(1) 시간 복잡도로 인덱스 기반 접근이 가능하므로, 리스트의 요소를 자주 조회해야 한다면 ArrayList 가 적합합니다.
        또한, 순서가 보장되므로 리스트의 끝에 요소를 추가하거나 삭제하는 작업도 매우 효율적입니다.
        반면 리스트의 중간에서 요소를 추가하거나 삭제할 때는 **O(n)**의 시간 복잡도가 발생합니다.

    LinkedList :
        MutableList 의 일종입니다.
        자료구조 중 LinkedList 와 동일하며, 장단점은 ArrayList 와 상반됩니다.
        리스트의 처음이나 중간에서 요소를 삽입하거나 삭제하는 작업이 O(1) 시간 복잡도로 빠르며,
        인덱스 기반 접근이 O(n) 시간 복잡도를 가지므로, 자주 인덱스 기반 접근을 해야 한다면 비효율적입니다.

- 동일 데이터베이스 내의 서로 다른 스키마간에는 외래키 설정이 불가능합니다.
    고로, 데이터베이스 설계시 되도록 스키마를 나누지 않는 것을 추천합니다.