[TODO]
- 데이터베이스 Join, Native Join 예시 추가
- 데이터베이스 기존 테이블에 fk 제약 추가

[REMIND]
- 트랜젝션 실행시 비동기 실행시 오작동을 할 수 있습니다.
예를들어 A 테이블의 a 컬럼이 null 이 아닌지 확인하고 null 이 아니라면 값을 입력하는 api 를 동시에 요청받았을 때,
이는 서로 다른 두 스레드에서 동시 실행이 되며, 실행하는 도중에는 트랜젝션 내에서 동작하므로, 두 요청 모두 null 체크를 통과한 상태로 진행을 하게 될 것입니다.

- 데이터베이스 기초 지식으로, MySQL 에서 nullable 컬럼에는 unique 제약을 하지 않는 것을 추천합니다.
예를들어 nullable 컬럼인 a 와 b 를 합성 unique 로 설정했을 때,
a 를 null 로 하고, b 를 2 로 입력하고,
다음에 또 a 를 null 로 하고 b 를 2 로 입력했을 때, 이것이 차단될 것이라고 생각하겠지만, null 이 들어간 순간 unique 제약은 동작을 하지 않고,
이상 없이 값이 들어갈 것입니다.
꼭 입력해야 한다면, 실제 변수는 not null 로 두고, null 에 해당하는 기본값을 정해놓아 사용하면 됩니다.

- 서버 개발자는 프로젝트에 들어가면 Raw Data 로 데이터를 뿌려주는 것보다는 기획서에 표시된 클라이언트 화면 단위로 전해주는 것을 우선으로 하세요.
예를들어 화면에서 품종이라고 표시된 데이터를 요청하면, 데이터베이스에 저장된 0, 1 등의 품종 코드 데이터를 그대로 주는게 아니라,
펜, 가위와 같이 실제 표시되는 데이터를 넘겨주는 것이 좋습니다.
Raw Data 반환의 경우,
서버 입장에서는 가공에 들어가는 연산량을 줄이고 코드를 간결하게 유지하면서,
실제 화면을 구성하는 모든 정보를 줬기에 끝이라고 생각할 수 있지만,
클라이언트 입장에서는 해당 변수의 조합을 통해 화면에 표시하는 것이 단순히 추가적인 수고가 드는 일이라기 보다는,
SEO 에도 연관이 되며, 해당 변수 조합이 복잡하다면 그 조합법을 서버측에서만 알고있으면 될 일을 클라이언트 측에까지 넘기는 일이 되기 때문입니다.
다만, 변수 조합이 그다지 복잡하지 않으면서 단순히 연산량이 큰 작업,
이미지 처리와 같은 미디어 파일 처리 등의 작업은 클라이언트 개발자와 상의하여 넘기는 방식으로 개발하면 좋습니다.
서비스 연결 관계를 보았을 때, 데이터베이스 서버보다는 서비스 서버가, 서비스 서버 보다는 클라이언트 서버가 바쁜 것이 경제적이지만,
위와 같은 예외가 존재합니다.

- JPA 네이티브 쿼리에서
TRUE, 혹은 FALSE 로 반환되는 변수는 매핑 객체에서 Boolean 그대로 받을 수 없고,
Long 타입으로 받습니다. (1L == True, 0L == False)

IF(
    join_info.uid IS NOT NULL AND
        (
            select
            count(*)
            FROM
            coverage_request
            where
            join_info_uid = join_info.uid and
            row_delete_date_str='-' and
            reject_or_payment_date is NULL
        ) >0,
        TRUE,
        FALSE
) AS insuranceRequest

예를들어 위와 같이 TRUE, 혹은 FALSE 를 반환하는 변수  insuranceRequest 를 받으려면,

interface NativeQueryOutputVo {
    var insuranceRequest: Long
}

이처럼 Long 으로 받도록 만들어야 합니다.

- API 컨트롤러의 변수명으로는 isXXX 란 이름을 사용하지 마세요.
예를들어, isEmpty 라는 변수명을 반환하도록 설계하였다면,
매핑시 isEmpty 가 반환되는 것이 아니라 empty 라는 이름으로 반환이 될 것입니다.